# --------------------------------------------------------------
# Used for new releases in GitHub Actions (draft or live)
# Updates existing infrastructure without recreating everything
# --------------------------------------------------------------

if [[ $1 != "live" ]] && [[ $1 != "test" ]]
then
  echo "Invalid deployment mode $1"
  exit
fi

# ==========================================
# ===  Step 0: Preparation (get params)  ===
# ==========================================

# Create flox.tfvars file from flox.config.json in frontend & backend
cd ../support || exit
zsh create-flox-tfvars.sh
echo "type=\"$1\"" >> flox.tfvars

# Get additional flox.config variables
project=$(jq '.general.project' ../../backend/flox.config.json)
project=${project:1:-1}

build_mode=$(jq '.general.mode' ../../frontend/flox.config.json)
build_mode=${build_mode:1:-1}

aws_region=$(jq '.general.aws_region' ../../backend/flox.config.json)
aws_region=${aws_region:1:-1}

organisation=$(jq '.general.organisation' ../../backend/flox.config.json)
organisation=${organisation:1:-1}

if [[ $1 == "test" ]]
then
  url=$(jq '.general.test_base_domain' ../../backend/flox.config.json)
else
  url=$(jq '.general.live_base_domain' ../../backend/flox.config.json)
fi
url=${url:1:-1}

# Go to pre-update folder
cd ../3_pre-update || exit

# Replace 'TYPE' in config.tf with actual type (live, test)
sed -i -e "s/##TYPE##/$1/g" config.tf

# Replace 'PROJECT' in config.tf with actual project name
sed -i -e "s/##PROJECT##/$project/g" config.tf

# Replace 'ORGANISATION' in config.tf with actual organisation name
sed -i -e "s/##ORGANISATION##/$organisation/g" config.tf

# Apply pre-update terraform for getting SSM parameters
terraform init
terraform apply -auto-approve -var-file="../support/flox.tfvars"

# Get variables from outputs
user_pool_id=$(terraform output user_pool_id)
user_pool_id=${user_pool_id:1:-1}
user_pool_client_id=$(terraform output user_pool_client_id)
user_pool_client_id=${user_pool_client_id:1:-1}
source_code_bucket=$(terraform output source_code_bucket)
source_code_bucket=${source_code_bucket:1:-1}
cognito_arn=$(terraform output cognito_arn)
cognito_arn=${cognito_arn:1:-1}
hosted_zone_id=$(terraform output hosted_zone_id)
hosted_zone_id=${hosted_zone_id:1:-1}

# Add Domain & Cognito outputs to flox.tfvars
echo "# ======== Domain Config ========" >> ../support/flox.tfvars
echo "base_domain=\"$url\"" >> ../support/flox.tfvars
echo "hosted_zone_id=\"$hosted_zone_id\"" >> ../support/flox.tfvars
echo "# ======== Cognito Config ========" >> ../support/flox.tfvars
echo "user_pool_id=\"$user_pool_id\"" >> ../support/flox.tfvars
echo "user_pool_client_id=\"$user_pool_client_id\"" >> ../support/flox.tfvars
echo "cognito_arn=\"$cognito_arnt\"" >> ../support/flox.tfvars
echo "# ======== S3 Config ========" >> ../support/flox.tfvars
echo "source_code_bucket=\"$source_code_bucket\"" >> ../support/flox.tfvars
# NOTE: as opposed to initial setup, cognito_arn is no longer needed here

# ==========================================
# ====       Step 1: Main Update        ====
# ==========================================

# Generate frontend .env file from outputs
cd ../../frontend || exit
rm -f .env
echo "# ======== Frontend AWS variables ========" >> .env
echo "# This file is AUTOGENERATED - do not edit!" >> .env
echo "# ==========================================" >> .env
echo "VUE_APP_GRAPHQL_ENDPOINT=https://api.$url/graphql" >> .env
echo "VUE_APP_NAME=$project-$1" >> .env
echo "VUE_APP_AWS_REGION=$aws_region" >> .env
echo "VUE_APP_USER_POOL_ID=$user_pool_id" >> .env
echo "VUE_APP_USER_POOL_CLIENT_ID=$user_pool_client_id" >> .env

# Go to update folder
cd ../scripts/4_update || exit

# Replace 'TYPE' in config.tf with actual type (live, test)
sed -i -e "s/##TYPE##/$1/g" config.tf

# Replace 'PROJECT' in config.tf with actual project name
sed -i -e "s/##PROJECT##/$project/g" config.tf

# Replace 'ORGANISATION' in config.tf with actual organisation name
sed -i -e "s/##ORGANISATION##/$organisation/g" config.tf

# Build & zip frontend and backend
zsh ../support/build.bash "$1" "$project" "$build_mode"
cp ../outputs/frontend.zip frontend.zip
cp ../outputs/backend.zip backend.zip

# Apply update Terraform
terraform init
terraform apply -auto-approve -var-file="../support/flox.tfvars"

# Get updated API version & apply to flox.tfvars (used as override in main-redeploy)
api_version=$(terraform output api_version)
api_version=${api_version:1:-1}
echo "# ======== API Config ========" >> ../support/flox.tfvars
echo "api_version=\"$api_version\"" >> ../support/flox.tfvars


# ==========================================
# ====    Step 2: Resource re-deploy   =====
# ==========================================

# Go to main Terraform workspace to re-apply Terraform (since EBS Env state is held there)
cd ../2_main-setup || exit

# Replace 'TYPE' in config.tf with actual type (live, test)
sed -i -e "s/##TYPE##/$1/g" config.tf

# Replace 'PROJECT' in config.tf with actual project name
sed -i -e "s/##PROJECT##/$project/g" config.tf

# Replace 'ORGANISATION' in config.tf with actual organisation name
sed -i -e "s/##ORGANISATION##/$organisation/g" config.tf

#terraform plan -target=aws_elastic_beanstalk_environment.api_env
terraform init
terraform apply -target=aws_elastic_beanstalk_environment.api_env -auto-approve -var-file="../support/flox.tfvars"

# TODO handle frontend as well

# ==========================================
# ====         Step 3: Cleanup         =====
# ==========================================

# Remove .zip files
rm -f ../4_update/frontend.zip
rm -f ../4_update/backend.zip

# Reset config.tf file to its respective template files
cp ../2_main-setup/config.tftemplate ../2_main-setup/config.tf
cp ../3_pre-update/config.tftemplate ../3_pre-update/config.tf
cp ../4_update/config.tftemplate ../4_update/config.tf
