<template>
  <QForm v-if="form" ref="formRef" :class="`q-gutter-md text-${textPosition}`">
    <!-- Stepper (for multi-page forms) -->
    <QStepper
      v-if="form.pages.length > 1"
      ref="stepper"
      v-model="form.step"
      active-color="primary"
      done-icon="done"
      animated
    >
      <q-step
        v-for="(page, index) in form.pages"
        :key="page.key"
        :name="index + 1"
        :prefix="index + 1"
        :title="page.label"
        :done="form.step > index"
      >
        <FormCard
          v-for="card in page.cards"
          :key="card.key"
          :card="card"
          class="q-mb-lg"
        >
          <div
            v-for="(field, fieldIndex) in card.fields"
            :key="`field_${fieldIndex}`"
          >
            <component
              :is="field.component"
              v-if="field"
              v-bind="{
                store,
                stateKey: {
                  formKey,
                  pageKey: page.key,
                  cardKey: card.key,
                  fieldKey: field.key,
                },
                ...field.attributes,
                options:
                  optionOverrides?.[field.key] ?? field.attributes.options,
              }"
            />
          </div>
        </FormCard>
      </q-step>
      <template #navigation>
        <q-stepper-navigation>
          <q-btn
            v-if="form.step > 1"
            color="primary"
            :label="$t('buttons.back')"
            flat
            style="margin-right: 30px"
            class="q-ml-sm"
            @click="$refs.stepper.previous()"
          />
          <q-btn
            v-if="form.step < form.pages.length"
            color="primary"
            :label="$t('buttons.next')"
            :disable="!form.pageValid"
            @click="toNext"
          />
          <q-btn
            v-if="form.step === form.pages.length"
            color="primary"
            :label="finishLabel"
            :disable="!form.pageValid"
            @click="onSubmit"
          />
        </q-stepper-navigation>
      </template>
    </QStepper>
    <!-- Single card (for single-page forms) -->
    <div v-else class="q-mb-lg">
      <component
        :is="field.component"
        v-for="field in form.pages[0].cards[0].fields"
        :key="field.key"
        class="q-mb-md"
        v-bind="{
          store,
          stateKey: {
            formKey,
            pageKey: form.pages[0].key,
            cardKey: form.pages[0].cards[0].key,
            fieldKey: field.key,
          },
          ...field.attributes,
          options: optionOverrides?.[field.key] ?? field.attributes.options,
        }"
      />

      <!-- Finish button -->
      <q-btn
        color="primary"
        :label="!loading ? finishLabel : loadingLabel"
        :class="`${ALTERNATE_BUTTON_CLASS} q-mt-md`"
        :style="`${DEFAULT_BUTTON_STYLE}`"
        :disable="loading"
        @click="onSubmit"
      >
        <q-inner-loading :showing="loading" />
      </q-btn>
    </div>
  </QForm>
</template>

<script setup lang="ts">
/**
 * This component defines a generic form that can have a single or multiple pages.
 * It takes the following properties:
 * @param {Object[]} pages - the pages to show, each containing fields, label and key
 * @param {string} [finishLabel] - the label to show on the 'finish' button
 * @param {string} [loadingLabel] - the label to show when loading
 * @param {boolean} [loading] - loading status to show on the finish button
 */
import { onBeforeMount, PropType, Ref, ref } from 'vue';
import { QForm, QStepper } from 'quasar';
import {
  ALTERNATE_BUTTON_CLASS,
  DEFAULT_BUTTON_STYLE,
} from 'src/css/defaultStyles';
import { FormStructure } from 'src/data/types/forms/generics/FormStructure';
import { FormPage } from 'src/data/types/forms/generics/FormPage';
import FormCard from 'components/cards/FormCard.vue';
import { useFormStore } from 'stores/form';
import { buildStoreSubstructure } from 'src/helpers/form/form-helpers';

import { i18n } from 'boot/i18n';

const props = defineProps({
  formKey: {
    type: String,
    required: true,
  },
  finishLabel: {
    type: String,
    required: false,
    default: i18n.global.t('buttons.finish'),
  },
  loadingLabel: {
    type: String,
    required: false,
    default: `${i18n.global.t('general.loading')}...`,
  },
  textPosition: {
    type: String,
    required: false,
    default: 'right',
  },
  pages: {
    type: Array as PropType<FormPage[]>,
    required: true,
    default: () => [],
  },
  loading: {
    type: Boolean,
    required: false,
    default: false,
  },
  flat: {
    type: Boolean,
    required: false,
    default: false,
  },
  // Whether the store state should be preserved when rebuilding the form
  preserveState: {
    type: Boolean,
    required: false,
    default: false,
  },
  // Manual override for field options (e.g. in GenericSelectFields): maps a field key to a list of options
  optionOverrides: {
    type: Object as PropType<Record<string, unknown[]>>,
    required: false,
    default: null,
  },
});

// Create Form instance with pages from props
const emit = defineEmits(['submit']);
const formRef: Ref<QForm | null> = ref(null);
const form: Ref<FormStructure | null> = ref(null);
const stepper: Ref<QStepper | null> = ref(null);

const store = useFormStore();

onBeforeMount(() => {
  // Initialize form structure
  form.value = new FormStructure(props.formKey, props.pages);

  // Set up store structure
  buildStoreSubstructure(props.formKey, props.pages, props.preserveState);
});

/**
 * Validates and, if valid, submits the form with all entered values
 * @returns {Promise<void>} - done
 */
async function onSubmit() {
  const isValid = await formRef.value?.validate();
  if (isValid) {
    emit('submit');
  }
}

/**
 * Goes to the next page and animated scrolling to the top of the page
 * @returns {void}
 */
function toNext() {
  stepper.value?.next();
  window.scrollTo({ top: 0, behavior: 'smooth' });
}
</script>
